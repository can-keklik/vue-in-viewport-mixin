{"version":3,"file":"in-viewport-mixin.min.js","sources":["../index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// Generated by CoffeeScript 2.5.1\n// Mixin definition\nvar indexOf = [].indexOf,\n    slice = [].slice;\nvar _default2 = {\n  // Public interface\n  props: {\n    // Add listeners and check if in viewport immediately\n    inViewportActive: {\n      type: Boolean,\n      default: true\n    },\n    // Only update once by default. The assumption is that it will be used for\n    // one-time buildins\n    inViewportOnce: {\n      type: Boolean,\n      default: false\n    },\n    // The IntersectionObserver root margin adds offsets to when the now and\n    // fully get updated.\n    inViewportRootMargin: {\n      type: Number | String,\n      default: '0px 0px -1px 0px'\n    },\n    // Specify the IntersectionObserver root to use.\n    inViewportRoot: {\n      type: String | Function | Object,\n      default: void 0\n    },\n    // The IntersectionObserver threshold defines the intersection ratios that\n    // fire the observer callback\n    inViewportThreshold: {\n      type: Number | Array,\n      default: function _default() {\n        return [0, 1 // Fire on enter/leave and fully enter/leave\n        ];\n      }\n    },\n    inViewportRequiresRoot: {\n      type: Boolean,\n      default: false\n    }\n  },\n  // Bindings that are used by the host component\n  data: function data() {\n    return {\n      inViewport: {\n        // Public props\n        now: null,\n        // Is in viewport\n        fully: null,\n        // Is fully in viewport\n        above: null,\n        // Is partially or fully above the viewport\n        below: null,\n        // Is partially or fully below the viewport\n        // Internal props\n        listening: false,\n        maxThreshold: 1\n      }\n    };\n  },\n  // Lifecycle hooks\n  mounted: function mounted() {\n    return this.$nextTick(this.inViewportInit);\n  },\n  destroyed: function destroyed() {\n    return this.removeInViewportHandlers();\n  },\n  computed: {\n    // Add the maxThreshold to the @inViewportThreshold prop so that the handler\n    // is fired for elements that are taller than the viewport\n    inViewportThresholdWithMax: function inViewportThresholdWithMax() {\n      var ref, threshold; // Support number and array thresholds\n\n      threshold = _typeof(this.inViewportThreshold) === 'object' ? this.inViewportThreshold : [this.inViewportThreshold]; // Add only if not already in the threshold list\n\n      if (ref = this.inViewport.maxThreshold, indexOf.call(threshold, ref) >= 0) {\n        return threshold;\n      } else {\n        return threshold.concat(this.inViewport.maxThreshold);\n      }\n    }\n  },\n  // Watch props and data\n  watch: {\n    // Add or remove event handlers handlers\n    inViewportActive: function inViewportActive(active) {\n      if (active) {\n        return this.addInViewportHandlers();\n      } else {\n        return this.removeInViewportHandlers();\n      }\n    },\n    // If any of the Observer options change, re-init.\n    inViewportRootMargin: function inViewportRootMargin() {\n      return this.reInitInViewportMixin();\n    },\n    inViewportRoot: function inViewportRoot() {\n      return function () {\n        if (this.inViewportRequiresRoot && !this.inViewportRoot) {\n          return this.removeInViewportHandlers();\n        } else {\n          return this.reInitInViewportMixin();\n        }\n      };\n    },\n    inViewportThresholdWithMax: function inViewportThresholdWithMax(now, old) {\n      if (now.toString() !== old.toString()) {\n        // In IE, this kept getting retriggered, so doing a manual comparison\n        // of old and new before deciding whether to take action.\n        return this.reInitInViewportMixin();\n      }\n    }\n  },\n  // Public API\n  methods: {\n    // Re-init\n    reInitInViewportMixin: function reInitInViewportMixin() {\n      this.removeInViewportHandlers();\n      return this.inViewportInit();\n    },\n    // Instantiate\n    inViewportInit: function inViewportInit() {\n      if (this.inViewportActive) {\n        return this.addInViewportHandlers();\n      }\n    },\n    // Add listeners\n    addInViewportHandlers: function addInViewportHandlers() {\n      if (this.inViewportRequiresRoot && !this.inViewportRoot) {\n        return;\n      } // Don't add twice\n\n\n      if (this.inViewport.listening) {\n        return;\n      }\n\n      this.inViewport.listening = true; // Create IntersectionObserver instance\n\n      this.inViewportObserver = new IntersectionObserver(this.updateInViewport, {\n        root: function () {\n          switch (_typeof(this.inViewportRoot)) {\n            case 'function':\n              return this.inViewportRoot();\n\n            case 'string':\n              return document.querySelector(this.inViewportRoot);\n\n            case 'object':\n              return this.inViewportRoot;\n            // Expects to be a DOMElement\n\n            default:\n              return void 0;\n          }\n        }.call(this),\n        rootMargin: this.inViewportRootMargin,\n        threshold: this.inViewportThresholdWithMax\n      }); // Start listening\n\n      return this.inViewportObserver.observe(this.$el);\n    },\n    // Remove listeners\n    removeInViewportHandlers: function removeInViewportHandlers() {\n      var ref; // Don't remove twice\n\n      if (!this.inViewport.listening) {\n        return;\n      }\n\n      this.inViewport.listening = false; // Destroy instance, which also removes listeners\n\n      if ((ref = this.inViewportObserver) != null) {\n        ref.disconnect();\n      }\n\n      return delete this.inViewportObserver;\n    },\n    // Handle state changes.  There should only ever be one entry and we're\n    // destructuring the properties we care about since they have long names.\n    updateInViewport: function updateInViewport(arg) {\n      var arg, root, target;\n\n      var _slice$call = slice.call(arg, -1);\n\n      var _slice$call2 = _slicedToArray(_slice$call, 1);\n\n      var _slice$call2$ = _slice$call2[0];\n      target = _slice$call2$.boundingClientRect;\n      root = _slice$call2$.rootBounds;\n      // Get the maximum threshold ratio, which is less than 1 when the\n      // element is taller than the viewport. The height may be 0 when the\n      // parent element is hidden.\n      this.inViewport.maxThreshold = target.height > 0 ? Math.min(1, root.height / target.height) : 1; // Check if some part of the target is in the root box.  The isIntersecting\n      // property from the IntersectionObserver was not used because it reports\n      // the case where a box is immediately offscreen as intersecting, even\n      // though no aprt of it is visible.\n\n      this.inViewport.now = target.top <= root.bottom && target.bottom > root.top; // Calculate above and below.  The +1 on the bottom check co-incides with\n      // the default root-margin which has a -1 on the bottom margin.\n\n      this.inViewport.above = target.top < root.top;\n      this.inViewport.below = target.bottom > root.bottom + 1; // Determine whether fully in viewport. The rules are different based on\n      // whether the target is taller than the viewport.\n\n      this.inViewport.fully = target.height > root.height ? target.top <= root.top && target.bottom >= root.bottom + 1 : !this.inViewport.above && !this.inViewport.below;\n\n      if (this.inViewportOnce && this.inViewport.now) {\n        // If set to update \"once\", remove listeners if in viewport\n        return this.removeInViewportHandlers();\n      }\n    }\n  }\n};\nexports.default = _default2;"],"names":["_slicedToArray","arr","i","Array","isArray","_arrayWithHoles","Symbol","iterator","Object","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","length","err","_iterableToArrayLimit","o","minLen","_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","from","test","_unsupportedIterableToArray","TypeError","_nonIterableRest","len","arr2","_typeof","obj","defineProperty","exports","indexOf","_default2","props","inViewportActive","type","Boolean","default","inViewportOnce","inViewportRootMargin","Number","String","inViewportRoot","Function","inViewportThreshold","inViewportRequiresRoot","data","inViewport","now","fully","above","below","listening","maxThreshold","mounted","this","$nextTick","inViewportInit","destroyed","removeInViewportHandlers","computed","inViewportThresholdWithMax","ref","threshold","concat","watch","active","addInViewportHandlers","reInitInViewportMixin","old","methods","inViewportObserver","IntersectionObserver","updateInViewport","root","document","querySelector","rootMargin","observe","$el","disconnect","arg","target","_slice$call2$","boundingClientRect","rootBounds","height","Math","min","top","bottom"],"mappings":"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"}