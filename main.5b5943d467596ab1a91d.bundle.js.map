{"version":3,"file":"main.5b5943d467596ab1a91d.bundle.js","sources":["webpack:///./index.coffee"],"sourcesContent":["# Mixin definition\nexport default\n\n\t# Public interface\n\tprops:\n\n\t\t# Add listeners and check if in viewport immediately\n\t\tinViewportActive:\n\t\t\ttype: Boolean\n\t\t\tdefault: true\n\n\t\t# Only update once by default. The assumption is that it will be used for\n\t\t# one-time buildins\n\t\tinViewportOnce:\n\t\t\ttype: Boolean\n\t\t\tdefault: false\n\n\t\t# The IntersectionObserver root margin adds offsets to when the now and\n\t\t# fully get updated.\n\t\tinViewportRootMargin:\n\t\t\ttype: Number|String\n\t\t\tdefault: '0px 0px -1px 0px'\n\n\t\t# Specify the IntersectionObserver root to use.\n\t\tinViewportRoot:\n\t\t\ttype: String|Function|Object\n\t\t\tdefault: undefined\n\n\t\t# The IntersectionObserver threshold defines the intersection ratios that\n\t\t# fire the observer callback\n\t\tinViewportThreshold:\n\t\t\ttype: Number|Array\n\t\t\tdefault: -> [0, 1] # Fire on enter/leave and fully enter/leave\n\n\t# Bindings that are used by the host component\n\tdata: -> inViewport:\n\n\t\t# Public props\n\t\tnow: null   # Is in viewport\n\t\tfully: null # Is fully in viewport\n\t\tabove: null # Is partially or fully above the viewport\n\t\tbelow: null # Is partially or fully below the viewport\n\n\t\t# Internal props\n\t\tlistening: false\n\t\tmaxThreshold: 1\n\n\t# Lifecycle hooks\n\tmounted: -> @$nextTick(@inViewportInit)\n\tdestroyed: -> @removeInViewportHandlers()\n\n\tcomputed:\n\n\t\t# Add the maxThreshold to the @inViewportThreshold prop so that the handler\n\t\t# is fired for elements that are taller than the viewport\n\t\tinViewportThresholdWithMax: ->\n\n\t\t\t# Support number and array thresholds\n\t\t\tthreshold =\n\t\t\t\tif typeof @inViewportThreshold == 'object'\n\t\t\t\tthen @inViewportThreshold\n\t\t\t\telse [ @inViewportThreshold ]\n\n\t\t\t# Add only if not already in the threshold list\n\t\t\tif @inViewport.maxThreshold in threshold\n\t\t\tthen threshold\n\t\t\telse threshold.concat @inViewport.maxThreshold\n\n\t# Watch props and data\n\twatch:\n\n\t\t# Add or remove event handlers handlers\n\t\tinViewportActive: (active) ->\n\t\t\tif active\n\t\t\tthen @addInViewportHandlers()\n\t\t\telse @removeInViewportHandlers()\n\n\t\t# If any of the Observer options change, re-init.\n\t\tinViewportRootMargin: -> @reInitInViewportMixin()\n\t\tinViewportRoot: -> @reInitInViewportMixin()\n\t\tinViewportThresholdWithMax: (now, old) ->\n\n\t\t\t# In IE, this kept getting retriggered, so doing a manual comparison\n\t\t\t# of old and new before deciding whether to take action.\n\t\t\t@reInitInViewportMixin() unless now.toString() == old.toString()\n\n\t# Public API\n\tmethods:\n\n\t\t# Re-init\n\t\treInitInViewportMixin: ->\n\t\t\t@removeInViewportHandlers()\n\t\t\t@inViewportInit()\n\n\t\t# Instantiate\n\t\tinViewportInit: -> @addInViewportHandlers() if @inViewportActive\n\n\t\t# Add listeners\n\t\taddInViewportHandlers: ->\n\n\t\t\t# Don't add twice\n\t\t\treturn if @inViewport.listening\n\t\t\t@inViewport.listening = true\n\n\t\t\t# Create IntersectionObserver instance\n\t\t\t@inViewportObserver = new IntersectionObserver @updateInViewport,\n\t\t\t\troot: switch typeof @inViewportRoot\n\t\t\t\t\twhen 'function' then @inViewportRoot()\n\t\t\t\t\twhen 'string' then document.querySelector @inViewportRoot\n\t\t\t\t\twhen 'object' then @inViewportRoot # Expects to be a DOMElement\n\t\t\t\t\telse undefined\n\t\t\t\trootMargin: @inViewportRootMargin\n\t\t\t\tthreshold: @inViewportThresholdWithMax\n\n\t\t\t# Start listening\n\t\t\t@inViewportObserver.observe @$el\n\n\t\t# Remove listeners\n\t\tremoveInViewportHandlers: ->\n\n\t\t\t# Don't remove twice\n\t\t\treturn unless @inViewport.listening\n\t\t\t@inViewport.listening = false\n\n\t\t\t# Destroy instance, which also removes listeners\n\t\t\t@inViewportObserver?.disconnect()\n\t\t\tdelete @inViewportObserver\n\n\t\t# Handle state changes.  There should only ever be one entry and we're\n\t\t# destructuring the properties we care about since they have long names.\n\t\tupdateInViewport: ([..., {\n\t\t\t\tboundingClientRect: target,\n\t\t\t\trootBounds: root\n\t\t\t}]) ->\n\n\t\t\t# Get the maximum threshold ratio, which is less than 1 when the\n\t\t\t# element is taller than the viewport. The height may be 0 when the\n\t\t\t# parent element is hidden.\n\t\t\t@inViewport.maxThreshold = if target.height > 0\n\t\t\tthen Math.min 1, root.height / target.height else 1\n\n\t\t\t# Check if some part of the target is in the root box.  The isIntersecting\n\t\t\t# property from the IntersectionObserver was not used because it reports\n\t\t\t# the case where a box is immediately offscreen as intersecting, even\n\t\t\t# though no aprt of it is visible.\n\t\t\t@inViewport.now = target.top <= root.bottom and target.bottom > root.top\n\n\t\t\t# Calculate above and below.  The +1 on the bottom check co-incides with\n\t\t\t# the default root-margin which has a -1 on the bottom margin.\n\t\t\t@inViewport.above = target.top < root.top\n\t\t\t@inViewport.below = target.bottom > root.bottom + 1\n\n\t\t\t# Determine whether fully in viewport. The rules are different based on\n\t\t\t# whether the target is taller than the viewport.\n\t\t\t@inViewport.fully = if target.height > root.height\n\t\t\tthen target.top <= root.top and target.bottom >= root.bottom + 1\n\t\t\telse not @inViewport.above and not @inViewport.below\n\n\t\t\t# If set to update \"once\", remove listeners if in viewport\n\t\t\t@removeInViewportHandlers() if @inViewportOnce and @inViewport.now\n"],"mappings":"AAAA","sourceRoot":""}